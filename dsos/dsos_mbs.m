function [PSOS,NSOS,DSOS]=dsos_mbs(p,ismatrixform)
    % Minimal basis spectral DSOS decomposition
    % Syntax:
    %   [PSOS,NSOS,DSOS]=DSOS_MBS(p,ismatrixform)
    % Inputs:
    % p: MPOLY polynomial
    % ismatrixform: results in matrix form or in polynomial form
    % Outputs:
    % PSOS: a SOS polynomial
    % NSOS: a SOS polynomial
    % DSOS: a SOS polynomial
    %produce the minimal basis
    [c,m]=coefficients(p);
    %subbasis=struct([]);
    subbasis=cell(length(c),1);
    for i=1:length(c)
        subbasis{i}=genminimalbasis(m(i).pow);
        %subbasis(i).pow=genminimalbasis(m(i).pow);
    end
    basispow=unique(vertcat(subbasis{:}),'rows');
    %basispow=unique(vertcat(subbasis.pow),'rows');
    % solve linear system to find Gram matrix Q
    [Q,b]=computeGram(p,basispow);
    % spectral decomposition
    [V,D]=eig(Q);
            
    if ismatrixform
        % results in matrix format (fastest)
        PSOS=[];
        NSOS=[];
        DSOS.L=D;
        DSOS.P=V;
        DSOS.b=b;

        % results in matrix format (separately)
        %lambda1=D;
        %lambda2=D;
        %lambda1(lambda1<0)=0;
        %lambda2(lambda2>0)=0;
        %PSOS.Q=V*lambda1*V';
        %PSOS.b=b;
        %NSOS.Q=V*(-lambda2)*V';
        %NSOS.b=b;
    else
        % quadprod computation (faster)
        lambda1=D;
        lambda2=D;
        lambda1(lambda1<0)=0;
        lambda2(lambda2>0)=0;
        PSOS=MPOLY.quadprod(V*lambda1*V',b);
        NSOS=MPOLY.quadprod(V*(-lambda2)*V',b);
        % direct computation (slowest)
        %PSOS=b'*(V*lambda1*V')*b;
        %NSOS=b'*(V*(-lambda2)*V')*b;
        DSOS=[];
    end
end

function subbasis=genminimalbasis(pow)
    % average decomposition to get pow of minimal basis
    subpow1=mod(pow,2);
    pow2=floor(pow/2);
    numnonzeros=sum(subpow1);
    if numnonzeros==0 % even degree only
        subbasis=pow2;
        return;
    else % if the set O is non-empty
        index=find(subpow1,ceil(numnonzeros/2));
        pow1=[subpow1;subpow1];
        pow1(1,index)=0;
        pow1(2,:)=subpow1-pow1(1,:);
        subbasis=pow1+pow2;
        return;
    end
end

function [Q,b] = computeGram(p,pow)
    % p: MPOLY polynomial
    % pow: pow matrix for a valid basis of p
    
    % lenb is the length of basis b
    lenb = size(pow,1);
    % n is the number of variables
    n=size(pow,2);
    % the basis b is the size of lenb
    b=MPOLY.ones(n,lenb,1);
    % the size of Q is lenb*lenb
    % let q be upper triangular part of Q, so that the size of q is
    % lenb*(lenb+1)/2
    lenq=lenb*(lenb+1)/2;
    isvectorize = true;
    if isvectorize % indexes + vectorization (more efficient)
        [r,c]=find(tril(true(lenb))); % create indexes
        powq=pow(r,:)+pow(c,:); % powq is the pow list of quadratic form b'*Q*b
        coefq=ones(lenq,1); % coefq is the leading coefficients of b'*Q*b
        coefq(logical(r-c))=2;
        for i=1:lenb
            b(i).pow=pow(i,:); % generate basis b
        end
    else % loops (less efficient)
        powq=zeros(lenq,n); % powq is the pow list of quadratic form b'*Q*b
        coefq=ones(lenq,1); % coefq is the leading coefficients of b'*Q*b
        idx=1;
        for i=1:lenb
            b(i).pow=pow(i,:); % generate basis b (MPOLY)
            for j=i:lenb
                powq(idx,:)=pow(i,:)+pow(j,:);
                if (i==j)
                    coefq(idx)=1; % for Qii*bi*bi
                else
                    coefq(idx)=2; % for 2*Qij*bi*bj with i<j
                end
                idx=idx+1;
            end
        end
    end
    % Create a linear system for q, solution of A*q=B
    % Note that since pow is a valide basis of p, so that all monomials in
    % p can be generated by pow
    gpumode=true; % set true to use gpu for acceleration
    if gpumode
        [~,ia,ic]=unique(gpuArray(full([powq;p.pow])),'rows'); % combine powq and p.pow and count unique monomials
        ia=gather(ia);
        ic=gather(ic);
    else
        [~,ia,ic]=unique([powq;p.pow],'rows'); % combine powq and p.pow and count unique monomials
    end
    allcoef = [coefq;p.coef]; % combine coefs
    nbrowA=length(ia); % length of unique monomials
    sparse_ver=1;
    if sparse_ver==1 % faster sparse version for large-scale computation
        B=zeros(nbrowA,1);
        % I,J,V for construct sparse matrix A
        I=ic(1:lenq);
        J=1:lenq;
        V=coefq;
        for i=lenq+1:lenq+p.k
            idx=ic(i);
            B(idx)=B(idx)+allcoef(i);
        end
        A=sparse(I,J,V);
        % solve the linear system A*q=B to get q
        q=A\B;
    elseif sparse_ver==0 % sparse version (old)
        B=zeros(nbrowA,1);
        labellst=1:(lenq+p.k);
        % I,J,V for construct sparse matrix A
        cc=1;
        I=zeros(1,lenq);
        J=I;
        V=I;
        for i=1:nbrowA
            % get row labels which equals to the ith monomial
            corlst=labellst(ic==i);
            % get common positions in the q part
            Apos=corlst(corlst<=lenq);
            % set the ith row of A
            %A(i,Apos)=coefq(Apos);
            len=length(Apos);
            I(cc:cc+len-1)=i;
            J(cc:cc+len-1)=Apos;
            V(cc:cc+len-1)=coefq(Apos);
            cc=cc+len;
            % get the common positions in the p part
            ppos=corlst(corlst>lenq);
            % compute the coefs in p for the ith monomial
            B(i)=sum(allcoef(ppos));
        end
        A=sparse(I(1:cc-1),J(1:cc-1),V(1:cc-1));
        % solve the linear system A*q=B to get q
        q=A\B;
    else
        % full matrix version
        A=zeros(nbrowA,lenq); % sparse(nbrowA,lenq);
        B=zeros(nbrowA,1);
        labellst=1:(lenq+p.k);
        for i=1:nbrowA
            % get row labels which equals to the ith monomial
            corlst=labellst(ic==i);
            % get common positions in the q part
            Apos=corlst(corlst<=lenq);
            % set the ith row of A
            A(i,Apos)=coefq(Apos);
            % get the common positions in the p part
            ppos=corlst(corlst>lenq);
            % compute the coefs in p for the ith monomial
            B(i)=sum(allcoef(ppos));
        end
        % solve the linear system A*q=B to get q
        q=sparse(A)\sparse(B);
    end
    % reforme q as matrix Q
    Q=lst2tril(q);
    diagq=diag(Q);
    Q=Q+Q';
    Q(logical(eye(size(Q))))=diagq;
end

function Q=lst2tril(q)
    % formulate a list q to lower triangular matrix by col order
    n=(-1+sqrt(1+8*length(q)))/2; % compute the size of Q
    Q=zeros(n);
    Q(tril(true(size(Q))))=q;
end
